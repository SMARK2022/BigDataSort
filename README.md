# BigDataSort

Nine freshmen's project which can sort 120G data of strings.

## **整个项目的任何内容，欢迎大家作出补充和修改，多直接上手尝试尝试是最好的学习方法。**

欢迎大家自己实验，可以自己创建一个新文件，用来存放自己代码做实验，也欢迎修改代码进行补充（记得做好备份）

## 目前的总体架构（传输开销还是很大，有 240G，大概传输需要近 10 分钟）

![架构demo1](./src/%E6%9E%B6%E6%9E%84demo1.png)

## 目前需要大家一同协作完成的工作事项：

- `[√]请教学长`：有机会或者资源的建议问一下上一届他们这个正确率方面和时间方面是怎么会有如此奇怪的结果的
- `[√]代码优化`：目前实现的效果还是只能说差强人意，大家有能力的希望尝试将 std 里面的 stable_sort 以及 tim_sort 尝试用结构体复现出来，这样应该会大大提速项目效率
- `[ ]查阅案例`：咱们根据最终的环境，找出一种实现效率最高的总体统筹算法，包括但不限于多线程、多台主机进行归并的方法等，比较重要的是`数据怎么存储、怎么切分、怎么传输`，查完可以写在文档中或者发在群里
- `[ ]架构优化`：目前效果还不错，但是可以优化架构继续减小时间、传输量

## 一些已知的 Tips：

- TimSort 这种排序算法可以查一下网上的解释，大概就是采用希尔排序与归并排序进行融合，我目前采用的 timsort 函数方法据说要再编译器中开`-O3`编译优化才能很快，实验发现，对于存在少部分有序的数据，timsort 效率较 stablesort 高。
- **传输开销小才是真的节省时间！传输开销大概占到程序总时间的 80%，所以降低传输量是关键！**
- 使用自己实现的结构体可以加快排序的操作速度，（应该是减小了内存的复制量与内存地址不对齐的问题）

## 目前的文件组成：

**目前我们的排序是使用 MuiltySort.cpp，并且打开-O3 编译，速度是相对来说比较快的**

| 文件名            | 简介/速度/性能     | 描述                                                                                                                                                             |
| ----------------- | ------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ./src/            | 该文档资源文件夹   | 一些图片等样例                                                                                                                                                   |
| ./MagicCUDA/      | 显卡 CUDA 排序程序 | 它有点逆天的快（ ,基于显卡的排序算法，有点高端我这种凡人难以修改                                                                                                 |
| ./UDPTransport/   | UDP 通讯的测试     | 存放着 UDP 通讯的测试，本地电脑测试的结果是，每秒钟传输 150M/s，错误率为 0%（也就是传输数据一般直接 UDP 传输应该不需要校验位进行校验）                           |
| ./tim/            | TimSort 支持库     | TimSort 排序的支持库，大致原理是把希尔排序与归并排序结合起来，需要使用-O3 编译优化                                                                               |
| ./MuiltySort.cpp  | 总共`133M/s`       | 基于 STL vector<Str> 自定义数据类型 容器实现的 stable_sort 与 tim_sort，同时将数据分块多线程读取，最后归并处理，速度大约为单个 CPU133M/s，1.6G/12s，打开-O3 优化 |
| ./SortString.java | 总共`32M/s`        | 基于 Java String 列表调用官方默认的 TimSort 方法，速度大约为多线程 160M/5s（暂时弃用）                                                                           |
| ./SortStr.cpp     | 单线程`64M/s`      | 基于 STL vector<Str> 自定义数据类型 容器实现的 stable_sort 与 tim_sort，速度大约为单线程 64M/1s，1.6G/25s，打开-O3 优化                                          |
| ./SortString.cpp  | 单线程`26M/s`      | 基于 STL vector<std::string> 容器实现的 stable_sort 与 tim_sort，速度大约为单线程 26M/s，160M/6s，打开-O3 优化（暂时弃用）                                       |
| ./generate.cpp    | 随机字符串生成     | 用来生成随机字符串，成功实现了多线程输出，能够跑满硬盘读写速度                                                                                                   |

## 我们未来可以实现的功能

欢迎大家积极尝试（可以直接 GPT 生成代码自己调试）:

- `[√]`实现多线程操作，从而完整调用多核性能，并可以想一下归并的思路
- `[ ]`想出新的排序架构，让多台电脑尽可能减少 120G 数据的传输量，同时不要让内存占用过高
- `[ ]`利用那位学长的思路，修改结构体，压缩传输数据量（修改为` 1 个 short + 1 个 long`） _short 2 字节 (26 \* 26 = 676) + long 8 字节 (26 ^ 13 = 2.48e+18 < LONG_MAX)_
- `[ ]`将 STL 的 vector 容器改为直接的结构体数组操作，这样可以加快排序迭代与内存分配的效率（效果可能不大）
