# BigDataSort

Nine freshmen's project which can sort 120G data of strings.

## **整个项目的任何内容，欢迎大家作出补充和修改，多直接上手尝试尝试是最好的学习方法。**

欢迎大家自己实验，可以自己创建一个新文件，用来存放自己代码做实验，也欢迎修改代码进行补充（记得做好备份）

## 目前需要大家一同协作完成的工作事项：

- `请教学长`：有机会或者资源的建议问一下上一届他们这个正确率方面和时间方面是怎么会有如此奇怪的结果的
- `查阅方法`：咱们根据最终的环境，找出一种实现效率最高的总体统筹算法，包括但不限于多线程、多台主机进行归并的方法等，查完可以写在文档中或者发在群里
- `代码优化`：目前实现的效果还是只能说差强人意，大家有能力的希望尝试将 std 里面的 stable_sort 以及 tim_sort 尝试用结构体复现出来，这样应该会大大提速项目效率

## 一些 Tips：

- TimSort 这种排序算法可以查一下网上的解释，大概就是采用希尔排序与归并排序进行融合，我目前采用的 timsort 函数方法据说要再编译器中开`-o3`优化才能很快，实验发现，对于存在少部分有序的数据，timsort 效率较 stablesort 高

## 目前的文件组成：

- `generate.cpp`：用来生成随机字符串
- `SortStr.cpp`：基于 STL vector<Str> 自定义数据类型 容器实现的 stable_sort 与 tim_sort，速度大概单线程 `160M/3s`, `1.6G/25s`, 打开`-O3`优化
- `SortString.cpp`：基于 STL vector<std::string> 容器实现的 stable_sort 与 tim_sort，速度大概单线程 `160M/6s`，打开`-O3`优化
- `SortString.java`: 基于 Java String 列表调用官方默认的 TimSort 方法，速度大概多线程 `160M/5s`

## 我们可以得出一些经验：

- 使用自己实现的结构体可以加快排序的操作速度，（应该是减小了内存的复制量与内存地址不对齐的问题）

## 我们未来可以实现的功能

欢迎大家积极尝试（可以直接 GPT 生成代码自己调试）:

- `[ ]`实现多线程操作，从而完整调用多核性能，并可以想一下归并的思路
- `[ ]`将 STL 的 vector 容器改为直接的结构体数组操作，这样可以加快排序迭代与内存分配的效率
